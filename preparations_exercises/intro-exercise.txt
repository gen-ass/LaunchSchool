/* intro-excercise

1.Concatenate two or more strings, one with your first name and one with your last, to create a string with your full name as its value. For example, if your name is John Doe, think about how you can put 'John' and 'Doe' together to get 'John Doe'.
> 'Peter ' + 'Parker' or console.log('Peter' + 'Parker');
= 'Peter Parker'

2. Use the arithmetic operators to determine the individual digits of a 4-digit number like 4936:
    thousands place is 4
    hundreds place is 9
    tens place is 3
    ones place is 6

> let number = 4936
> let ones = number % 10
> ones
= 6

> number = (number - ones) / 10
= 493

> let tens = number % 10
> tens
= 3

> number = (number - tens) / 10
= 49

> let hundreds = number % 10
> hundreds
= 9

> let thousands = (number - hundreds) / 10
> thousands
= 4

3 Identify the data type for each of the following values:

    'true' = string
    false = bolean
    1.5 = number
    2 =  number
    undefined = undefined
    { foo: 'bar' } = object

4 Explain why this code logs '510' instead of 15.

console.log('5' + 10); // The first value console logged of '5' is a stirng the second value console logged is a number. When a string and a number is "added" together, JS will implicitly coerce the number to a string, the printed value is a string. Every + operation will be coerced to a string.

5 Refactor the code from the previous exercise to use explicit coercion, so it logs 15 instead.

> console.log(Number('5') + 10);
= 15
> parseInt('5') + 10 or console.log(parseInt('5') + 10);
= 15
> parseFloat('5') + 10 or console.log(parseFloat('5') + 10);
= 15


6 Use the template literal syntax along with the expression Number('5') + 10 to log the following sentence to the console:

The value of 5 + 10 is 15.
> `The value of 5 + 10 is ${Number('5') + 10}.` or console.log(`The value of 5 + 10 is ${Number('5') + 10}.`);

7 Will an error occur if you try to access an array element with an index that is greater than or equal to the length of the array? For example:


let foo = ['a', 'b', 'c'];
console.log(foo.length);  // => 3
console.log(foo[3]);      // will this result in an error? It will result in a undefined value. The Array only has 3 elements in the array. The request is for a fourth element on index 3, the index count in the current array is 2 and there is only three elements.

8 Create an array named; names that contains a list of pet names. For instance:

names = [
'pasta',
'butterscotch',
'pudding',
'neptune',
'darwin',
]

9 Create an object named pets that contains a list of pet names and the type of animal. For instance:

let pets = {
pasta: 	'dog',
butterscotch: 	'cat',
pudding: 	'cat',
neptune: 	'fish',
darwin: 	'lizard'
}

10 What value does the following expression evaluate to?

> parseInt('3.1415')
= 3 // parseInt() will convert the string to a number, but it will only convert the string before the decimal to a number, the rest will be ignored.

12 What value does the following expression evaluate to?

> '12' < '9'
= true // JS does a character by character evalution on the string. This implies, '1' < '9' so '12' is less than it is true. If you add '92' < '9' it becomes false, as '9' is not less but the same.

https://launchschool.com/books/javascript/read/variables#variablesandvariablenames

Variables and Names

Variable names are often referred to by the broader term, identifiers. In JavaScript, identifiers refer to several things:

- Variable names declared by let and var
- Constant names declared by const
- Property names of objects
- Function names
- Function parameters
- Class names


> let a = 4
= undefined

> let b = a
= undefined

> a = 7
= 7

> b
= 4 // The reason b is assigned to its own memory space, a is also assigned to it's own memory space. b then gets reference to the value of a, in this case a is 4. So b will look to a only for an answer. Later a gets the value of seven assigned. B now has the value of a in memory, that was assigned in the first instance. a has a new value, but can't see that value as it is not updated to "know" it. a doesn't tell b it has a new value. b keeps its value it has in memory which is 4.

For b to know the value of a, you need to reassign it to a again. a = b then b will be 7 as well

https://launchschool.com/books/javascript/read/variables#declaringconstants
Declaring Constants

Constants have an immutable binding to their values. Unlike an ordinary variable, once you declare a constant, you cannot assign it a new value. The constant will continue to have that value until the constant is no longer needed.


https://launchschool.com/books/javascript/read/variables#variablescope
Variable scope

In general, blocks appear in if...else if...else, while, do...while, for, switch, and try...catch statements, or by themselves (as in the first example above).

1 Write a program named greeter.js that greets 'Victor' three times. Your program should use a variable and not hard code the string value 'Victor' in each greeting. Here's an example run of the program:

node greeter.js
Good Morning, Victor.
Good Afternoon, Victor.
Good Evening, Victor.

2 Write a program named age.js that includes someone's age and then calculates and reports the future age in 10, 20, 30 and 40 years. Below is the output for someone 20 years old.

You are 20 years old.
In 10 years, you will be 30 years old.
In 20 years, you will be 40 years old.
In 30 years, you will be 50 years old.
In 40 years, you will be 60 years old.

3 What happens when you run the following program? Why do we get that result?

{
  let foo = 'bar';
}

console.log(foo);

// Console log will print Undefined, as the variable has local scope using the let keyword, but if you use the var keyword it will have global scope and will print 'bar' to the console 


4 What happens when you run the following code? Why?

const NAME = 'Victor';
console.log('Good Morning, ' + NAME);
console.log('Good Afternoon, ' + NAME);
console.log('Good Evening, ' + NAME);

NAME = 'Joe';
console.log('Good Morning, ' + NAME);
console.log('Good Afternoon, ' + NAME);
console.log('Good Evening, ' + NAME);

// The code will print: Uncaught TypeError: invalid assignment to const 'NAME'. The keyword const or constant has been declared with variable NAME. const or constants can't be re-assigned, as is being tried with NAME = 'Joe'. To re-assign a variable you must change it the let variable, ex: let name = 'Joe'; console.log('Good Morning, ' + name); name = 'Joe';
console.log('Good Morning, ' + name);


5 Take a look at this code snippet:

let foo = 'bar';
{
  let foo = 'qux';
}

console.log(foo);

// let foo = 'bar' has been declared wich can be re-assigned, but it's not being re-assigned outside the block scope at all. The { let foo = 'bar'; } inside the block isn't accessible. 

6 Will this program produce an error when run? Why or why not?


const FOO = 'bar';
{
  const FOO = 'qux';
}

console.log(FOO);

// const FOO = 'bar' is decalred out side the block scope, and because it is a constant you would have assumed a, Uncaught SyntaxError: redeclaration of const FOO or some other error. Because of the code block that is not the case and the 'bar' will be printed in the console. 

https://launchschool.com/books/javascript/read/input_output#commandlineoutput
Input / Output

1 Write a dynamic greeter program named greeter.js. The program should ask for your name, then output Hello, {name}! where {name} is the name you entered:

$ node greeter.js
What is your name? Sue
Hello, Sue!

let name = 'Sue';
console.log(`Good morning, ${name}!`);



2 Modify the greeter.js program to ask for the user's first and last names separately, then greet the user with their full name.

$ node greeter.js
What is your first name? Sue
What is your last name? Roberts
Hello, Sue Roberts!

let rlSync1 = require('readline-sync');
let name1 = rlSync.question("What's your first name?\n");
let surname1 = rlSync.question("What's your last name?\n");
console.log(`Good Morning, ${name} ${surname}!`);


3 Modify the age.js program you wrote in the exercises for the Variables chapter. The updated code should ask the user to enter their age instead of hard-coding the age in the program. Here's an example run:

How old are you? 22
You are 22 years old.
In 10 years, you will be 32 years old.
In 20 years, you will be 42 years old.
In 30 years, you will be 52 years old.
In 40 years, you will be 62 years old.


// https://launchschool.com/books/javascript/read/functions#usingfunctions
Functions

Before you can use a function, you must first define it with the reserved keyword, function. After the word function, you write the function's name followed by a pair of parentheses (()). After the closing parenthesis, the code you want to associate with the function -- the function body -- gets placed between curly braces ({}).


function=function definition say=function name(words=parameter defined) function body={
  console.log=method(words=parameter printed);
}

say=call the function("hello"=pass the value to the function);
say("hi");
say("how are you");
say("I'm fine");

At first glance, this program seems silly. It doesn't reduce the amount of code, and in fact, it adds more; quite a bit more. Also, the say function doesn't provide any functionality that console.log doesn't. However, there is a benefit here. We've extracted the logic to display text in a way that makes our program more flexible. If we later need to change how we show some text, we can make the change in one place: the say function. We don't have to change any other code to get the updated behavior. We'll see such an update in a few minutes.

Functions are called by typing their name and providing some optional values that we call arguments. In say.js, the function definition includes (words) after the function name. This syntax tells us that we should supply (pass) a single argument to the function when we call it. Arguments let you pass data from outside the function's scope into the function so it can access the data. If the function definition doesn't need access to outside data, you don't need any arguments.

In the definition of a function, the names between parentheses are called parameters. The arguments are the values of those parameters.

Function names and parameters are both considered variable names in JavaScript. Parameters, in particular, are local variables; they are only defined locally, within the body of the function.


Programmers often talk about function invocation and invoking functions. The terms are synonymous with "call" and "calling." You invoke a function or write a function invocation. We use these terms as well.


Programmers often talk about function invocation and invoking functions. The terms are synonymous with "call" and "calling." You invoke a function or write a function invocation. We use these terms as well.

The local variable names between parenthesis (()) are properly called parameters, not arguments. Arguments are the values you pass into the function for each of those parameters. The parameter values inside the function are also called arguments. You can think of parameters as placeholders, while arguments refer to the values that get stored in the placeholders.

function add(left, right) { // left & right are parameters here
  let sum = left + right;   // left & right are arguments here
  return sum;
}

let sum = add(3, 6); // 3 and 6 are arguments


// https://launchschool.com/books/javascript/read/functions#returnvalues
Retun values

undefined; this is the implicit return value of most JavaScript functions.
However, when you use a return statement, you can return a specific value from a function. This is an explicit return value. 


function add(a, b) {
  return a + b;
}

add(2, 3); // returns 5


Functions that always return a boolean value, i.e., true or false, are called predicates. You will almost certainly encounter this term in future readings and videos, so commit it to memory.

// https://launchschool.com/books/javascript/read/functions#defaultparametrs
Default Parameters

function say(words = "hello") {
  console.log(words + "!");
}

say("Howdy"); // => Howdy!
say();        // => hello!

If nothing is passed to the parameter 'words' then the default value printed will be 'hello', as this is the default if no argument is evaluated it returns the the default parameter

// https://launchschool.com/books/javascript/read/functions#nestedfunctions
Nested Functions


function foo() {
  function bar() {
    console.log("BAR");
  }

  bar(); // => BAR
  bar(); // => BAR
}

foo();
bar(); // ReferenceError: bar is not defined

nested funtion can't be called from outside of the nested function itself, this creates a private function. Performance is negligible here.

// https://launchschool.com/books/javascript/read/functions#functionsscope
Functions & Scope

Two main variables: global and local, declare by let and const


global

let greetingMessage = "Good Morning!";
console.log(greetingMessage);

// This will print a global variable and is accessible to the whole program.


let greetingMessage = "Good Morning!";

function greetPeople() {
  console.log(greetingMessage);
}

greetPeople();

// the function declaration can call from inside the function body or code block, the global variable as it's assigned outside of any code block or function


function greetPeople() {
  console.log(greetingMessage);
}

function changeGreetingMessage(newMessage) {
  greetingMessage = newMessage;
}

changeGreetingMessage("Good Evening");
greetPeople(); // => 'Good Evening'

// We've added a changeGreetingMessage function to our program that reassigns greetingMessage to a new string supplied as an argument. Line 11 invokes the function, passing in the 'Good Evening' string, which becomes the new value for the global greetingMessage.

local

function greetPeople() {
  let greetingMessage = "Good Morning!";
  console.log(greetingMessage);
}

greetPeople();
console.log(greetingMessage); // raises ReferenceError: Uncaught ReferenceError: greetingMessage is not defined

// value can only be used within, not elsewhere

// Local variables have a short life span, as sson as the function completes the scope goes away. This allows the program to add new variables to the local variable. The scope is then restarted and the new variable is passed to the parameter within function. This parameter overwrites the and current parameter in memory. This happens to allow memory to be re-used otjerwise it will lock the memory, making the block unusable. The program crashes. 


// https://launchschool.com/books/javascript/read/functions#functionsvsmethods
Functions vs Methods

Thus far, all our function calls used functionName(obj) syntax. We call a function by writing parentheses after its name and passing it zero or more arguments. If you want to convert a string to all uppercase letters, you might expect to use a function call like toUpperCase(string). However, you need to use a different syntax called method invocation.

Method invocation occurs when you prepend a variable name or value followed by a period (.) to a function invocation, e.g. 'xyzzy'.toUpperCase().


Parameters are fields that serve as variable names inside of a function. 

Arguments are the values passed to the function when it is called. 

// https://launchschool.com/books/javascript/read/functions#mutatingthecaller
Mutate the caller
Sometimes a method permanently alters the object that invokes the method: it mutates the caller. To contrast this with non-mutating methods, let's see an example:

let name = "Pete Hanson";
console.log(name.toUpperCase()); // => 'PETE HANSON'
console.log(name);               // => 'Pete Hanson'


// toUpperCase() as a string method, mutates the string in a non-destructive manner. It has no effect on the caller: name. It leaves it as is.


let oddNumbers = [1, 3, 5, 7, 9];
oddNumbers.pop();
console.log(oddNumbers); // => [1, 3, 5, 7]

// The pop() method will permanently alter the array above. It mutates the object, which is the object: array.


function changeFirstElement(array) {
  array[0] = 9;
}

let oneToFive = [1, 2, 3, 4, 5];
changeFirstElement(oneToFive);
console.log(oneToFive); // => [9, 2, 3, 4, 5]

// Here the argument is mutataed using the index syntax. It will alter the array when the subtax runs.


function addToArray(array) {
  return array.concat(10);
}

let oneToFive = [1, 2, 3, 4, 5];
console.log(addToArray(oneToFive)); // => [1, 2, 3, 4, 5, 10]
console.log(oneToFive);             // => [1, 2, 3, 4, 5]

One non-obvious point here is that mutation is a concern when dealing with arrays and objects, but not with primitive values like numbers, strings, and booleans. Primitive values are immutable. That means their values never change: operations on immutable values always return new values. Operations on mutable values (arrays and objects) may or may not return a new value and may or may not mutate data.

If you have experience programming in other languages and wonder whether JavaScript is a pass-by-value or pass-by-reference language, JavaScript is both! It uses pass-by-value when dealing with primitive values and pass-by-reference with objects and arrays.


// https://launchschool.com/books/javascript/read/functions#functioncomposition
Function Composition

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

let sum = add(20, 45);
console.log(sum); // => 65

let difference = subtract(80, 10);
console.log(difference); // => 70

This works fine. However, in a process called function composition, JavaScript lets us use a function call as an argument to another function. Stated differently, we're saying that we can pass add(20, 45) and subtract(80, 10) as arguments to another function:


// https://launchschool.com/books/javascript/read/functions#threewaystodefineafunction
Three Ways to Define a Function


this is a function: function declaration.
function functionName(zeroOrMoreArguments...) {
  // function body
}

// Function declarations will be hoisted to the top of the code block being run, because of this it can be invoked before it is declared .


Let's see another way to define a function called a function expression.

let greetPeople = () => {
  console.log("Good Morning!");
};

greetPeople();

// Function expressions cannot be hoisted/invoked before it is declared

We can do that since JavaScript functions are first-class functions. The key feature of first-class functions is that you can treat them like any other value. In fact, all JavaScript functions are objects. So technically, all objects in JavaScript are accessed on the same level or seen having the same importance when using it in the program.

These objects be used as follows:
- assign them to variables, 
- pass them as arguments to other functions, 
- and return them from a function call.

With arrow functions you can, leave the return statement. We can omit it in arrow functions when and only when the function body contains a single expression (the expression may have subexpressions, but the entire expression must evaluate to a single value). Suppose it contains two or more expressions or statements. In that case, you must explicitly return a value if you need it, and you must also use curly braces:

let add = (a, b) => a + b;
let getNumber = (text) => {
  let input = prompt(text);
  return Number(input);
};

let number1 = getNumber("Enter a number: ");
let number2 = getNumber("Enter another number: ");
console.log(add(number1, number2));

On line #2, we define an arrow function that requires one parameter. The parentheses around the parameter name are optional in this case and are often omitted.

// https://launchschool.com/books/javascript/read/functions#callstack
Call stack

https://pythontutor.com/visualize.html#mode=display to visualise the call stack
https://www.youtube.com/watch?v=W8AeMrVtFLY video explains call stack

function first() {
  console.log("first function");
}

function second() {
  first();
  console.log("second function");
}

second();


1 What does this code log to the console? Does executing the foo function affect the output? Why or why not?

let bar = 1;
function foo() {
  let bar = 2;  // remove the let keyword now it assigns bar = 2; to be avaiable outside the function
}

foo();
console.log(bar);

// It has no effect on the outcome of bar. bar is declared with let inside the function foo() the {} braces indicates, a local scope is created. Bar remains 1, as the local scope contains bar from being declared the value of 2.

To get bar to become the value of 2, we need to change the local scope inside the foo() fucntion. By removing let and assigning bar = 2; we make the value globally available. Now the line will print, 2

2 In the exercises for the previous chapter, you wrote a dynamic greeter program named greeter.js. Add a function to this program that solicits the user's first and last names in separate invocations; the function should return the appropriate name as a string. Use the return values to greet the user with their fullname:

function getName(prompt) {
  let readlineSync = require('readline-sync');
  let name = readlineSync.question(prompt);
  return name;
}

let firstName = getName('What is your first name? ');
let lastName = getName('What is your last name? ');
console.log(`Hello, ${firstName} ${lastName}!`);


3 Write a program that uses a multiply function to multiply two numbers and returns the result. Ask the user to enter the two numbers, then output the numbers and result as a simple equation


$ node multiply.js
Enter the first number: 3.141592653589793
Enter the second number: 2.718281828459045
3.141592653589793 * 2.718281828459045 = 8.539734222673566


4 What does the following code log to the console?

function scream(words) {
  words = words + '!!!!';
  return;
  console.log(words);
}

scream('Yipeee');

// When a return statement is used in a function body, the execution of the function is stopped. If specified, a given value is returned to the function caller. This implies the return; statement will not run console.log words. It will directly return any value to the function caller scream(). The value is still available in memory, but it's not printed for humans to see.


5 What does the following code log to the console?

function scream(words) {
  return words + '!!!!';
}

scream('Yipeee');

// Nothing as return has done the execution of the code. 


// https://launchschool.com/books/javascript/read/flow_control
Flow control

Conditionals
A conditional is a fork (or multiple forks) in the road. Your data arrives at a conditional, which then tells the data where to go. The simplest conditionals use a combination of if statements with comparison and logical operators (<, >, <=, >=, ==, ===, !=, !==, &&, ||) to direct traffic. They use the keywords if and else.



if (x === 3) {                          // Example 1
  console.log("x is 3");
}

if (x === 3) {                          // Example 2
  console.log("x is 3");
} else {
  console.log("x is NOT 3");
}

if (x === 3) console.log("x is 3");     // Example 3

if (x === 3)                            // Example 4
  console.log("x is 3");

if (x === 3)                            // Example 5
  console.log("x is 3");
else
  console.log("x is NOT 3");

if (x === 3) {                          // Example 6
  console.log('x is 3');
} else {
  if (x === 4) {
    console.log('x is 4');
  } else {
    console.log('x is NOT 3 or 4');
  }
}

if (x === 3) {                          // Example 7
  console.log("x is 3");
} else if (x === 4) {
  console.log("x is 4");
} else {
  console.log('x is NOT 3 or 4');
}




// https://launchschool.com/books/javascript/read/flow_control#comparisons
Comparison


===
The strict equality operator, also known as the identity operator, returns true when the operands have the same type and value, false otherwise. We discussed === in The Basics chapter. It should be familiar even if it still looks strange.


!==
The strict inequality operator returns false when the operands have the same type and value, true otherwise. Note that !== is the inverse of ===: when === returns true, !== returns false, and vice versa.


== - These creates coercion
The non-strict equality operator, also known as the loose equality operator, is similar to ===. However, when the operands have different types, == attempts to coerce one of the operands to the other operand's type before it compares them, and it may coerce both operands in some cases. The result is true when the final values are the same, false otherwise. The coercion behavior can lead to unexpected results. For instance, when we compare the number 5 to the string '5' using ==, we get true; with ===, we get false.

!= - These creates coercion
The non-strict inequality operator, also known as the loose inequality operator, is similar to !==. However, when the operands have different types, != attempts to coerce one of the operands to the other operand's type before it compares them, and it may coerce both operands in some cases. The result is false when the final values are the same, true otherwise.


The rules that govern which operand == and != coerces to the other are complex and difficult to remember. Avoid these operators when you can. For instance, you can use explicit coercion and === in most cases.

That advice is not universal. There are JavaScript developers, including some well-known ones, who will tell you to go ahead and use the loose operators, == and !=. Their reasoning is easy to understand: your code should not be attempting to compare different kinds of things, except in a few well-defined, isolated cases. Using the strict operators as a workaround is just masking bad code. They're not completely wrong! If you're comparing strings with arrays, your code almost certainly needs a redesign.

That said, there are some edge cases that you need to be aware of with the loose operators. For that reason, the style we use at Launch School insists that you always use the strict operators. Doing so won't prevent you from having to fix bad code, but at this stage of your journey, it's less confusing to use the strict operators, and easier to debug.


<
The less than operator returns true when the value of the left operand has a value that is less than the value of the right operand, false otherwise.

When comparing strings, the comparison is character-by-character. JavaScript moves from left-to-right in the strings looking for the first character that is different from its counterpart in the other string. Once it finds a character that differs, it compares that character with its counterpart, and makes a decision based on that.

>
The greater than operator returns true when the value of the left operand has a value that is greater than the value of the right operand, false otherwise.

<=
The less than or equal to operator returns true when the value of the left operand has a value that is less than or equal to the value of the right operand, false otherwise. Note that =< is not a valid comparison operator.

>=
The greater than or equal to operator returns true when the value of the left operand has a value that is greater than or equal to the value of the right operand, false otherwise. Note that => is not a valid comparison operator.


https://launchschool.com/books/javascript/read/flow_control#logicaloperators
Logical Operators

!
The not operator returns true when its operand is false and returns false when the operand is true. That is, it negates its operand. Note that, unlike most operators, ! takes a single operand; the operand appears to the right of the operator.

&&
The and operator returns true when both operands are true and false when either operand is false.

||
The or operator returns true when either operand is true and false when both operands are false.

https://launchschool.com/books/javascript/read/flow_control#shortcircuits
Short Circuits

https://launchschool.com/books/javascript/read/flow_control#truthiness
Truthiness


Why is that? The answer is simple: when coercing a value to a boolean, JavaScript treats the following values as false:

    false
    The number 0. This includes all 3 variations of zero in JavaScript:
        0: The ordinary zero value.
        -0: A negative zero. That's mathematical nonsense, but a real thing in JavaScript.
        0n: The BigInt version of zero.
    An empty string ('')
    undefined
    null
    NaN


We often use the term falsy to refer to values that evaluate as false, while the values that evaluate as true are truthy. We use these terms when we need to distinguish between boolean true and false values. We can also discuss truthiness: whether something is a truthy or falsy value.

Truthiness is exceptionally useful in JavaScript; there are plenty of situations where you want to treat the values 0 (all 3 variants), '', undefined, null, and NaN as though they were false. It helps make conditional expressions read more naturally, but it can also catch an unwary programmer by surprise. If you have experience with another language that uses falsy values, be wary; most languages don't share the same idea of what values are falsy. That's a constant headache for programmers that work with multiple languages.

Let's return to the if (x = 5) example. When you see code like that, it's important to remember that x = 5 is an assignment. It returns 5, which, in turn, is a truthy value. You should avoid using assignments in conditionals: at first glance, if (x = 5) and if (x == 5) look identical. However, they have entirely different meanings and produce different results. That makes the code suspect: the assignment might be intentional, but it might also be a mistake, and mistakes are bugs waiting to bite the unwary. Worse yet, another programmer may come along and naively "fix" the code.

let isOk = !!(foo || bar);

In reality, !! isn't a separate operator in JavaScript. Instead, it's two consecutive ! operators. The expression !!a is equivalent to writing !(!a). The inner ! converts the value of a to false if it is truthy, or true if a is falsy. The outer ! then flips true to false or false to true. In the end, we end up with a boolean value instead of a truthiness value:


https://launchschool.com/books/javascript/read/flow_control#operatorprecedence
Operator Precedence

JavaScript has a set of precedence rules it uses to evaluate expressions that use multiple operators and sub-expressions. The following is a list of the comparison operations from the highest precedence (top) to lowest (bottom).

    <=, <, >, >= - Comparison
    ===, !==, ==, != - Equality
    && - Logical AND
    || - Logical OR

if ((x || y) && z) {
  // do something
}

In this code, x || y gets evaluated first, and then result && z. That's a different result from the un-parenthesized expression. They help the computer and other programmers understand your intentions, you should strive to use parentheses in any expression that uses two or more different operators.

JavaScript evaluates parentheses in the usual algebraic order. That is, it evaluates the expression in the innermost set of parentheses first, then works its way out to the outermost part of the expression. When multiple parenthesized subexpressions appear at the same depth, it evaluates them from left to right. Once it evaluates the parenthesized expressions, it evaluates the final expression value.

hort-circuit evaluation may prevent JavaScript from evaluating the expression to the right of the operator, but the precedence rules remain the same.


https://launchschool.com/books/javascript/read/flow_control#theternaryoperator
The Ternary Operator


The ternary operator is a quick and easy way to write a short, concise, and simple if/else conditional. It uses a combination of the ? and : symbols and takes 3 operands (hence, the name "ternary"):

> 1 == 1 ? 'this is true' : 'this is not true'
= 'this is true'

> 1 == 0 ? "this is true" : "this is not true"
= 'this is not true'
 
 How does this work? JavaScript first evaluates the first operand (the comparisons). If it has a truthy result, JavaScript evaluates the second operand (this is true) and returns its value. Otherwise, it evaluates the third operand (this is not true) and returns its value.

The chief advantage that the ternary operator has over an if/else statement is that the entire structure is an expression. What that means is that we can treat the ternary expression as a value: we can assign it to a variable, pass it as an argument, and so on. Since if/else is a statement, we can't capture its result to a variable.

more ternary examples
var age = 20;
var beverage = (age >= 21) ? "Beer" : "Juice";
console.log(beverage); // "Beer"

Handling null values

One common usage is to handle a value that may be null:

let greeting = person => {
    let name = person ? person.name : `stranger`
    return `Howdy, ${name}`
}

console.log(greeting({name: `Alice`}));  // "Howdy, Alice"
console.log(greeting(null));             // "Howdy, stranger"

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator
Conditional chains

The ternary operator is right-associative, which means it can be "chained" in the following way, similar to an if … else if … else if … else chain


https://launchschool.com/books/javascript/read/flow_control#switchstatement
switch statement

The last conditional flow structure we want to discuss is the switch statement. A switch statement is similar to an if statement, but it has a different interface. It compares a single value against multiple values for strict equality (as with the === operator), whereas if can test multiple expressions with any condition.

1 What values do the following expressions evaluate to?

false || (true && false); // false
true || (1 + 2); // true first operand is true, so it returns true
(1 + 2) || true; // 3  first operand is 3 and is then returned. However, the || operator actually returns the value of one of the specified operands, so if this operator is used with non-Boolean values, it will return a non-Boolean value.   The or operator returns true when either operand is true and false when both operands are false.
true && (1 + 2); // 3  However, the && operator actually returns the value of one of the specified operands, so if this operator is used with non-Boolean values, it will return a non-Boolean value.     The and operator returns true when both operands are true and false when either operand is false.
false && (1 + 2); // false The first operation is FALSE. The and operator returns true when both operands are true and false when either operand is false.
(1 + 2) && true; // true use and logical operator, but starts with parentheses calculates number, both operands is true, 
(32 * 4) >= 129; // false compares two numbers, but starts with parentheses then compares
false !== !true; // false strict not operator and not operation turns boolean values to the opposite values
true === 4; // false boolean strictly compared with number 
false === (847 === '847'); // true strict operator
false === (847 == '847'); // false coercion
(!true || (!(100 / 5) === 20) || ((328 / 4) === 82)) || false;

2 Write a function, evenOrOdd, that determines whether its argument is an even number. If it is, the function should log 'even' to the console; otherwise, it should log 'odd'. For now, assume that the argument is always an integer.

3 Let's improve our previous implementation of evenOrOdd. Add a validation check to ensure that the argument is an integer. If it isn't, the function should issue an error message and return.

4 What does the following code log to the console, and why?

function barCodeScanner(serial) {
  switch (serial) {
    case '123':
      console.log('Product1');
    case '113':
      console.log('Product2');
    case '142':
      console.log('Product3');
    default:
      console.log('Product not found!');
  }
}

barCodeScanner('113');

Product2
Product3
Product not found!


It prints all the cases and the default case and stops. No break keyword is included. This creates a fall-through. It does not care that input 113 match Product2. Nothing tells the program to stop.


5 Refactor this statement to use an if statement instead.

return foo() ? 'bar' : qux();

if (foo()) {
  return 'bar';
} else {
  return qux();
}


6 What does this code output to the console?

function isArrayEmpty(arr) {
  if (arr) {
    console.log('Not Empty');
  } else {
    console.log('Empty');
  }
}

isArrayEmpty([]);

The array is not empty. the length of the array is calculated and returns 0. This is a value in the empty array.

7 Write a function that takes a string as an argument and returns an all-caps version of the string when the string is longer than 10 characters. Otherwise, it should return the original string. Example: change 'hello world' to 'HELLO WORLD', but don't change 'goodbye'.

function capital(stringInput) {
	if (stringInput.length > 10 && stringInput === 'string') {
		return stringInput.toUpperCase();
	} else {
		stringInput = stringInput;
	}
  return stringInput;
}

function getString(prompt) {
  let readlineSync = require('readline-sync');
  return (readlineSync.question(prompt.toString()));
}

let stringInput = getString('Enter any value: ');
console.log(`Is the string ${stringInput} capitalised ${stringInput.length > 10 ? '--YES--' : '--NO--'} ${capital(stringInput)} - Characters counted: ${stringInput.length}`);





*/