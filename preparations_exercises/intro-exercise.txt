/* intro-excercise

1.Concatenate two or more strings, one with your first name and one with your last, to create a string with your full name as its value. For example, if your name is John Doe, think about how you can put 'John' and 'Doe' together to get 'John Doe'.
> 'Peter ' + 'Parker' or console.log('Peter' + 'Parker');
= 'Peter Parker'

2. Use the arithmetic operators to determine the individual digits of a 4-digit number like 4936:
    thousands place is 4
    hundreds place is 9
    tens place is 3
    ones place is 6

> let number = 4936
> let ones = number % 10
> ones
= 6

> number = (number - ones) / 10
= 493

> let tens = number % 10
> tens
= 3

> number = (number - tens) / 10
= 49

> let hundreds = number % 10
> hundreds
= 9

> let thousands = (number - hundreds) / 10
> thousands
= 4

3 Identify the data type for each of the following values:

    'true' = string
    false = bolean
    1.5 = number
    2 =  number
    undefined = undefined
    { foo: 'bar' } = object

4 Explain why this code logs '510' instead of 15.

console.log('5' + 10); // The first value console logged of '5' is a stirng the second value console logged is a number. When a string and a number is "added" together, JS will implicitly coerce the number to a string, the printed value is a string. Every + operation will be coerced to a string.

5 Refactor the code from the previous exercise to use explicit coercion, so it logs 15 instead.

> console.log(Number('5') + 10);
= 15
> parseInt('5') + 10 or console.log(parseInt('5') + 10);
= 15
> parseFloat('5') + 10 or console.log(parseFloat('5') + 10);
= 15


6 Use the template literal syntax along with the expression Number('5') + 10 to log the following sentence to the console:

The value of 5 + 10 is 15.
> `The value of 5 + 10 is ${Number('5') + 10}.` or console.log(`The value of 5 + 10 is ${Number('5') + 10}.`);

7 Will an error occur if you try to access an array element with an index that is greater than or equal to the length of the array? For example:


let foo = ['a', 'b', 'c'];
console.log(foo.length);  // => 3
console.log(foo[3]);      // will this result in an error? It will result in a undefined value. The Array only has 3 elements in the array. The request is for a fourth element on index 3, the index count in the current array is 2 and there is only three elements.

8 Create an array named; names that contains a list of pet names. For instance:

names = [
'pasta',
'butterscotch',
'pudding',
'neptune',
'darwin',
]

9 Create an object named pets that contains a list of pet names and the type of animal. For instance:

let pets = {
pasta: 	'dog',
butterscotch: 	'cat',
pudding: 	'cat',
neptune: 	'fish',
darwin: 	'lizard'
}

10 What value does the following expression evaluate to?

> parseInt('3.1415')
= 3 // parseInt() will convert the string to a number, but it will only convert the string before the decimal to a number, the rest will be ignored.

12 What value does the following expression evaluate to?

> '12' < '9'
= true // JS does a character by character evalution on the string. This implies, '1' < '9' so '12' is less than it is true. If you add '92' < '9' it becomes false, as '9' is not less but the same.

https://launchschool.com/books/javascript/read/variables#variablesandvariablenames

Variables and Names

Variable names are often referred to by the broader term, identifiers. In JavaScript, identifiers refer to several things:

- Variable names declared by let and var
- Constant names declared by const
- Property names of objects
- Function names
- Function parameters
- Class names


> let a = 4
= undefined

> let b = a
= undefined

> a = 7
= 7

> b
= 4 // The reason b is assigned to its own memory space, a is also assigned to it's own memory space. b then gets reference to the value of a, in this case a is 4. So b will look to a only for an answer. Later a gets the value of seven assigned. B now has the value of a in memory, that was assigned in the first instance. a has a new value, but can't see that value as it is not updated to "know" it. a doesn't tell b it has a new value. b keeps its value it has in memory which is 4.

For b to know the value of a, you need to reassign it to a again. a = b then b will be 7 as well

https://launchschool.com/books/javascript/read/variables#declaringconstants
Declaring Constants

Constants have an immutable binding to their values. Unlike an ordinary variable, once you declare a constant, you cannot assign it a new value. The constant will continue to have that value until the constant is no longer needed.


https://launchschool.com/books/javascript/read/variables#variablescope
Variable scope

In general, blocks appear in if...else if...else, while, do...while, for, switch, and try...catch statements, or by themselves (as in the first example above).

1 Write a program named greeter.js that greets 'Victor' three times. Your program should use a variable and not hard code the string value 'Victor' in each greeting. Here's an example run of the program:

node greeter.js
Good Morning, Victor.
Good Afternoon, Victor.
Good Evening, Victor.

2 Write a program named age.js that includes someone's age and then calculates and reports the future age in 10, 20, 30 and 40 years. Below is the output for someone 20 years old.

You are 20 years old.
In 10 years, you will be 30 years old.
In 20 years, you will be 40 years old.
In 30 years, you will be 50 years old.
In 40 years, you will be 60 years old.

3 What happens when you run the following program? Why do we get that result?

{
  let foo = 'bar';
}

console.log(foo);

// Console log will print Undefined, as the variable has local scope using the let keyword, but if you use the var keyword it will have global scope and will print 'bar' to the console 


4 What happens when you run the following code? Why?

const NAME = 'Victor';
console.log('Good Morning, ' + NAME);
console.log('Good Afternoon, ' + NAME);
console.log('Good Evening, ' + NAME);

NAME = 'Joe';
console.log('Good Morning, ' + NAME);
console.log('Good Afternoon, ' + NAME);
console.log('Good Evening, ' + NAME);

// The code will print: Uncaught TypeError: invalid assignment to const 'NAME'. The keyword const or constant has been declared with variable NAME. const or constants can't be re-assigned, as is being tried with NAME = 'Joe'. To re-assign a variable you must change it the let variable, ex: let name = 'Joe'; console.log('Good Morning, ' + name); name = 'Joe';
console.log('Good Morning, ' + name);


5 Take a look at this code snippet:

let foo = 'bar';
{
  let foo = 'qux';
}

console.log(foo);

// let foo = 'bar' has been declared wich can be re-assigned, but it's not being re-assigned outside the block scope at all. The { let foo = 'bar'; } inside the block isn't accessible. 

6 Will this program produce an error when run? Why or why not?


const FOO = 'bar';
{
  const FOO = 'qux';
}

console.log(FOO);

// const FOO = 'bar' is decalred out side the block scope, and because it is a constant you would have assumed a, Uncaught SyntaxError: redeclaration of const FOO or some other error. Because of the code block that is not the case and the 'bar' will be printed in the console. 

https://launchschool.com/books/javascript/read/input_output#commandlineoutput
Input / Output

1 Write a dynamic greeter program named greeter.js. The program should ask for your name, then output Hello, {name}! where {name} is the name you entered:

$ node greeter.js
What is your name? Sue
Hello, Sue!

let name = 'Sue';
console.log(`Good morning, ${name}!`);



2 Modify the greeter.js program to ask for the user's first and last names separately, then greet the user with their full name.

$ node greeter.js
What is your first name? Sue
What is your last name? Roberts
Hello, Sue Roberts!

let rlSync1 = require('readline-sync');
let name1 = rlSync.question("What's your first name?\n");
let surname1 = rlSync.question("What's your last name?\n");
console.log(`Good Morning, ${name} ${surname}!`);


3 Modify the age.js program you wrote in the exercises for the Variables chapter. The updated code should ask the user to enter their age instead of hard-coding the age in the program. Here's an example run:

How old are you? 22
You are 22 years old.
In 10 years, you will be 32 years old.
In 20 years, you will be 42 years old.
In 30 years, you will be 52 years old.
In 40 years, you will be 62 years old.


// https://launchschool.com/books/javascript/read/functions#usingfunctions
Functions

Before you can use a function, you must first define it with the reserved keyword, function. After the word function, you write the function's name followed by a pair of parentheses (()). After the closing parenthesis, the code you want to associate with the function -- the function body -- gets placed between curly braces ({}).


function=function definition say=function name(words=parameter defined) function body={
  console.log=method(words=parameter printed);
}

say=call the function("hello"=pass the value to the function);
say("hi");
say("how are you");
say("I'm fine");

At first glance, this program seems silly. It doesn't reduce the amount of code, and in fact, it adds more; quite a bit more. Also, the say function doesn't provide any functionality that console.log doesn't. However, there is a benefit here. We've extracted the logic to display text in a way that makes our program more flexible. If we later need to change how we show some text, we can make the change in one place: the say function. We don't have to change any other code to get the updated behavior. We'll see such an update in a few minutes.

Functions are called by typing their name and providing some optional values that we call arguments. In say.js, the function definition includes (words) after the function name. This syntax tells us that we should supply (pass) a single argument to the function when we call it. Arguments let you pass data from outside the function's scope into the function so it can access the data. If the function definition doesn't need access to outside data, you don't need any arguments.

In the definition of a function, the names between parentheses are called parameters. The arguments are the values of those parameters.

Function names and parameters are both considered variable names in JavaScript. Parameters, in particular, are local variables; they are only defined locally, within the body of the function.


Programmers often talk about function invocation and invoking functions. The terms are synonymous with "call" and "calling." You invoke a function or write a function invocation. We use these terms as well.


Programmers often talk about function invocation and invoking functions. The terms are synonymous with "call" and "calling." You invoke a function or write a function invocation. We use these terms as well.

The local variable names between parenthesis (()) are properly called parameters, not arguments. Arguments are the values you pass into the function for each of those parameters. The parameter values inside the function are also called arguments. You can think of parameters as placeholders, while arguments refer to the values that get stored in the placeholders.

function add(left, right) { // left & right are parameters here
  let sum = left + right;   // left & right are arguments here
  return sum;
}

let sum = add(3, 6); // 3 and 6 are arguments


// https://launchschool.com/books/javascript/read/functions#returnvalues
Retun values

undefined; this is the implicit return value of most JavaScript functions.
However, when you use a return statement, you can return a specific value from a function. This is an explicit return value. 


function add(a, b) {
  return a + b;
}

add(2, 3); // returns 5


Functions that always return a boolean value, i.e., true or false, are called predicates. You will almost certainly encounter this term in future readings and videos, so commit it to memory.

// https://launchschool.com/books/javascript/read/functions#defaultparametrs
Default Parameters

function say(words = "hello") {
  console.log(words + "!");
}

say("Howdy"); // => Howdy!
say();        // => hello!

If nothing is passed to the parameter 'words' then the default value printed will be 'hello', as this is the default if no argument is evaluated it returns the the default parameter

// https://launchschool.com/books/javascript/read/functions#nestedfunctions
Nested Functions


function foo() {
  function bar() {
    console.log("BAR");
  }

  bar(); // => BAR
  bar(); // => BAR
}

foo();
bar(); // ReferenceError: bar is not defined

nested funtion can't be called from outside of the nested function itself, this creates a private function. Performance is negligible here.

// https://launchschool.com/books/javascript/read/functions#functionsscope
Functions & Scope

Two main variables: global and local, declare by let and const


global

let greetingMessage = "Good Morning!";
console.log(greetingMessage);

// This will print a global variable and is accessible to the whole program.


let greetingMessage = "Good Morning!";

function greetPeople() {
  console.log(greetingMessage);
}

greetPeople();

// the function declaration can call from inside the function body or code block, the global variable as it's assigned outside of any code block or function


function greetPeople() {
  console.log(greetingMessage);
}

function changeGreetingMessage(newMessage) {
  greetingMessage = newMessage;
}

changeGreetingMessage("Good Evening");
greetPeople(); // => 'Good Evening'

// We've added a changeGreetingMessage function to our program that reassigns greetingMessage to a new string supplied as an argument. Line 11 invokes the function, passing in the 'Good Evening' string, which becomes the new value for the global greetingMessage.

local

function greetPeople() {
  let greetingMessage = "Good Morning!";
  console.log(greetingMessage);
}

greetPeople();
console.log(greetingMessage); // raises ReferenceError: Uncaught ReferenceError: greetingMessage is not defined

// value can only be used within, not elsewhere

// Local variables have a short life span, as sson as the function completes the scope goes away. This allows the program to add new variables to the local variable. The scope is then restarted and the new variable is passed to the parameter within function. This parameter overwrites the and current parameter in memory. This happens to allow memory to be re-used otjerwise it will lock the memory, making the block unusable. The program crashes. 


// https://launchschool.com/books/javascript/read/functions#functionsvsmethods
Functions vs Methods

Thus far, all our function calls used functionName(obj) syntax. We call a function by writing parentheses after its name and passing it zero or more arguments. If you want to convert a string to all uppercase letters, you might expect to use a function call like toUpperCase(string). However, you need to use a different syntax called method invocation.

Method invocation occurs when you prepend a variable name or value followed by a period (.) to a function invocation, e.g. 'xyzzy'.toUpperCase().


Parameters are fields that serve as variable names inside of a function. 

Arguments are the values passed to the function when it is called. 

// https://launchschool.com/books/javascript/read/functions#mutatingthecaller
Mutate the caller
Sometimes a method permanently alters the object that invokes the method: it mutates the caller. To contrast this with non-mutating methods, let's see an example:

let name = "Pete Hanson";
console.log(name.toUpperCase()); // => 'PETE HANSON'
console.log(name);               // => 'Pete Hanson'


// toUpperCase() as a string method, mutates the string in a non-destructive manner. It has no effect on the caller: name. It leaves it as is.


let oddNumbers = [1, 3, 5, 7, 9];
oddNumbers.pop();
console.log(oddNumbers); // => [1, 3, 5, 7]

// The pop() method will permanently alter the array above. It mutates the object, which is the object: array.


function changeFirstElement(array) {
  array[0] = 9;
}

let oneToFive = [1, 2, 3, 4, 5];
changeFirstElement(oneToFive);
console.log(oneToFive); // => [9, 2, 3, 4, 5]

// Here the argument is mutataed using the index syntax. It will alter the array when the subtax runs.


function addToArray(array) {
  return array.concat(10);
}

let oneToFive = [1, 2, 3, 4, 5];
console.log(addToArray(oneToFive)); // => [1, 2, 3, 4, 5, 10]
console.log(oneToFive);             // => [1, 2, 3, 4, 5]

One non-obvious point here is that mutation is a concern when dealing with arrays and objects, but not with primitive values like numbers, strings, and booleans. Primitive values are immutable. That means their values never change: operations on immutable values always return new values. Operations on mutable values (arrays and objects) may or may not return a new value and may or may not mutate data.

If you have experience programming in other languages and wonder whether JavaScript is a pass-by-value or pass-by-reference language, JavaScript is both! It uses pass-by-value when dealing with primitive values and pass-by-reference with objects and arrays.


// https://launchschool.com/books/javascript/read/functions#functioncomposition
Function Composition

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

let sum = add(20, 45);
console.log(sum); // => 65

let difference = subtract(80, 10);
console.log(difference); // => 70

This works fine. However, in a process called function composition, JavaScript lets us use a function call as an argument to another function. Stated differently, we're saying that we can pass add(20, 45) and subtract(80, 10) as arguments to another function:


// https://launchschool.com/books/javascript/read/functions#threewaystodefineafunction
Three Ways to Define a Function


this is a function: function declaration.
function functionName(zeroOrMoreArguments...) {
  // function body
}

// Function declarations will be hoisted to the top of the code block being run, because of this it can be invoked before it is declared .


Let's see another way to define a function called a function expression.

let greetPeople = () => {
  console.log("Good Morning!");
};

greetPeople();

// Function expressions cannot be hoisted/invoked before it is declared

We can do that since JavaScript functions are first-class functions. The key feature of first-class functions is that you can treat them like any other value. In fact, all JavaScript functions are objects. So technically, all objects in JavaScript are accessed on the same level or seen having the same importance when using it in the program.

These objects be used as follows:
- assign them to variables, 
- pass them as arguments to other functions, 
- and return them from a function call.

With arrow functions you can, leave the return statement. We can omit it in arrow functions when and only when the function body contains a single expression (the expression may have subexpressions, but the entire expression must evaluate to a single value). Suppose it contains two or more expressions or statements. In that case, you must explicitly return a value if you need it, and you must also use curly braces:

let add = (a, b) => a + b;
let getNumber = (text) => {
  let input = prompt(text);
  return Number(input);
};

let number1 = getNumber("Enter a number: ");
let number2 = getNumber("Enter another number: ");
console.log(add(number1, number2));

On line #2, we define an arrow function that requires one parameter. The parentheses around the parameter name are optional in this case and are often omitted.

// https://launchschool.com/books/javascript/read/functions#callstack
Call stack

https://pythontutor.com/visualize.html#mode=display to visualise the call stack
https://www.youtube.com/watch?v=W8AeMrVtFLY video explains call stack

function first() {
  console.log("first function");
}

function second() {
  first();
  console.log("second function");
}

second();


1 What does this code log to the console? Does executing the foo function affect the output? Why or why not?

let bar = 1;
function foo() {
  let bar = 2;  // remove the let keyword now it assigns bar = 2; to be avaiable outside the function
}

foo();
console.log(bar);

// It has no effect on the outcome of bar. bar is declared with let inside the function foo() the {} braces indicates, a local scope is created. Bar remains 1, as the local scope contains bar from being declared the value of 2.

To get bar to become the value of 2, we need to change the local scope inside the foo() fucntion. By removing let and assigning bar = 2; we make the value globally available. Now the line will print, 2

2 In the exercises for the previous chapter, you wrote a dynamic greeter program named greeter.js. Add a function to this program that solicits the user's first and last names in separate invocations; the function should return the appropriate name as a string. Use the return values to greet the user with their fullname:

function getName(prompt) {
  let readlineSync = require('readline-sync');
  let name = readlineSync.question(prompt);
  return name;
}

let firstName = getName('What is your first name? ');
let lastName = getName('What is your last name? ');
console.log(`Hello, ${firstName} ${lastName}!`);


3 Write a program that uses a multiply function to multiply two numbers and returns the result. Ask the user to enter the two numbers, then output the numbers and result as a simple equation


$ node multiply.js
Enter the first number: 3.141592653589793
Enter the second number: 2.718281828459045
3.141592653589793 * 2.718281828459045 = 8.539734222673566


4 What does the following code log to the console?

function scream(words) {
  words = words + '!!!!';
  return;
  console.log(words);
}

scream('Yipeee');

// When a return statement is used in a function body, the execution of the function is stopped. If specified, a given value is returned to the function caller. This implies the return; statement will not run console.log words. It will directly return any value to the function caller scream(). The value is still available in memory, but it's not printed for humans to see.


5 What does the following code log to the console?

function scream(words) {
  return words + '!!!!';
}

scream('Yipeee');

// Nothing as return has done the execution of the code. 


// https://launchschool.com/books/javascript/read/flow_control
Flow control

Conditionals
A conditional is a fork (or multiple forks) in the road. Your data arrives at a conditional, which then tells the data where to go. The simplest conditionals use a combination of if statements with comparison and logical operators (<, >, <=, >=, ==, ===, !=, !==, &&, ||) to direct traffic. They use the keywords if and else.



if (x === 3) {                          // Example 1
  console.log("x is 3");
}

if (x === 3) {                          // Example 2
  console.log("x is 3");
} else {
  console.log("x is NOT 3");
}

if (x === 3) console.log("x is 3");     // Example 3

if (x === 3)                            // Example 4
  console.log("x is 3");

if (x === 3)                            // Example 5
  console.log("x is 3");
else
  console.log("x is NOT 3");

if (x === 3) {                          // Example 6
  console.log('x is 3');
} else {
  if (x === 4) {
    console.log('x is 4');
  } else {
    console.log('x is NOT 3 or 4');
  }
}

if (x === 3) {                          // Example 7
  console.log("x is 3");
} else if (x === 4) {
  console.log("x is 4");
} else {
  console.log('x is NOT 3 or 4');
}




// https://launchschool.com/books/javascript/read/flow_control#comparisons
Comparison


===
The strict equality operator, also known as the identity operator, returns true when the operands have the same type and value, false otherwise. We discussed === in The Basics chapter. It should be familiar even if it still looks strange.


!==
The strict inequality operator returns false when the operands have the same type and value, true otherwise. Note that !== is the inverse of ===: when === returns true, !== returns false, and vice versa.


== - These creates coercion
The non-strict equality operator, also known as the loose equality operator, is similar to ===. However, when the operands have different types, == attempts to coerce one of the operands to the other operand's type before it compares them, and it may coerce both operands in some cases. The result is true when the final values are the same, false otherwise. The coercion behavior can lead to unexpected results. For instance, when we compare the number 5 to the string '5' using ==, we get true; with ===, we get false.

!= - These creates coercion
The non-strict inequality operator, also known as the loose inequality operator, is similar to !==. However, when the operands have different types, != attempts to coerce one of the operands to the other operand's type before it compares them, and it may coerce both operands in some cases. The result is false when the final values are the same, true otherwise.


The rules that govern which operand == and != coerces to the other are complex and difficult to remember. Avoid these operators when you can. For instance, you can use explicit coercion and === in most cases.

That advice is not universal. There are JavaScript developers, including some well-known ones, who will tell you to go ahead and use the loose operators, == and !=. Their reasoning is easy to understand: your code should not be attempting to compare different kinds of things, except in a few well-defined, isolated cases. Using the strict operators as a workaround is just masking bad code. They're not completely wrong! If you're comparing strings with arrays, your code almost certainly needs a redesign.

That said, there are some edge cases that you need to be aware of with the loose operators. For that reason, the style we use at Launch School insists that you always use the strict operators. Doing so won't prevent you from having to fix bad code, but at this stage of your journey, it's less confusing to use the strict operators, and easier to debug.


<
The less than operator returns true when the value of the left operand has a value that is less than the value of the right operand, false otherwise.

When comparing strings, the comparison is character-by-character. JavaScript moves from left-to-right in the strings looking for the first character that is different from its counterpart in the other string. Once it finds a character that differs, it compares that character with its counterpart, and makes a decision based on that.

>
The greater than operator returns true when the value of the left operand has a value that is greater than the value of the right operand, false otherwise.

<=
The less than or equal to operator returns true when the value of the left operand has a value that is less than or equal to the value of the right operand, false otherwise. Note that =< is not a valid comparison operator.

>=
The greater than or equal to operator returns true when the value of the left operand has a value that is greater than or equal to the value of the right operand, false otherwise. Note that => is not a valid comparison operator.


https://launchschool.com/books/javascript/read/flow_control#logicaloperators
Logical Operators

!
The not operator returns true when its operand is false and returns false when the operand is true. That is, it negates its operand. Note that, unlike most operators, ! takes a single operand; the operand appears to the right of the operator.

&&
The and operator returns true when both operands are true and false when either operand is false.

||
The or operator returns true when either operand is true and false when both operands are false.

https://launchschool.com/books/javascript/read/flow_control#shortcircuits
Short Circuits

https://launchschool.com/books/javascript/read/flow_control#truthiness
Truthiness


Why is that? The answer is simple: when coercing a value to a boolean, JavaScript treats the following values as false:

    false
    The number 0. This includes all 3 variations of zero in JavaScript:
        0: The ordinary zero value.
        -0: A negative zero. That's mathematical nonsense, but a real thing in JavaScript.
        0n: The BigInt version of zero.
    An empty string ('')
    undefined
    null
    NaN


We often use the term falsy to refer to values that evaluate as false, while the values that evaluate as true are truthy. We use these terms when we need to distinguish between boolean true and false values. We can also discuss truthiness: whether something is a truthy or falsy value.

Truthiness is exceptionally useful in JavaScript; there are plenty of situations where you want to treat the values 0 (all 3 variants), '', undefined, null, and NaN as though they were false. It helps make conditional expressions read more naturally, but it can also catch an unwary programmer by surprise. If you have experience with another language that uses falsy values, be wary; most languages don't share the same idea of what values are falsy. That's a constant headache for programmers that work with multiple languages.

Let's return to the if (x = 5) example. When you see code like that, it's important to remember that x = 5 is an assignment. It returns 5, which, in turn, is a truthy value. You should avoid using assignments in conditionals: at first glance, if (x = 5) and if (x == 5) look identical. However, they have entirely different meanings and produce different results. That makes the code suspect: the assignment might be intentional, but it might also be a mistake, and mistakes are bugs waiting to bite the unwary. Worse yet, another programmer may come along and naively "fix" the code.

let isOk = !!(foo || bar);

In reality, !! isn't a separate operator in JavaScript. Instead, it's two consecutive ! operators. The expression !!a is equivalent to writing !(!a). The inner ! converts the value of a to false if it is truthy, or true if a is falsy. The outer ! then flips true to false or false to true. In the end, we end up with a boolean value instead of a truthiness value:


https://launchschool.com/books/javascript/read/flow_control#operatorprecedence
Operator Precedence

JavaScript has a set of precedence rules it uses to evaluate expressions that use multiple operators and sub-expressions. The following is a list of the comparison operations from the highest precedence (top) to lowest (bottom).

    <=, <, >, >= - Comparison
    ===, !==, ==, != - Equality
    && - Logical AND
    || - Logical OR

if ((x || y) && z) {
  // do something
}

In this code, x || y gets evaluated first, and then result && z. That's a different result from the un-parenthesized expression. They help the computer and other programmers understand your intentions, you should strive to use parentheses in any expression that uses two or more different operators.

JavaScript evaluates parentheses in the usual algebraic order. That is, it evaluates the expression in the innermost set of parentheses first, then works its way out to the outermost part of the expression. When multiple parenthesized subexpressions appear at the same depth, it evaluates them from left to right. Once it evaluates the parenthesized expressions, it evaluates the final expression value.

hort-circuit evaluation may prevent JavaScript from evaluating the expression to the right of the operator, but the precedence rules remain the same.


https://launchschool.com/books/javascript/read/flow_control#theternaryoperator
The Ternary Operator


The ternary operator is a quick and easy way to write a short, concise, and simple if/else conditional. It uses a combination of the ? and : symbols and takes 3 operands (hence, the name "ternary"):

> 1 == 1 ? 'this is true' : 'this is not true'
= 'this is true'

> 1 == 0 ? "this is true" : "this is not true"
= 'this is not true'
 
 How does this work? JavaScript first evaluates the first operand (the comparisons). If it has a truthy result, JavaScript evaluates the second operand (this is true) and returns its value. Otherwise, it evaluates the third operand (this is not true) and returns its value.

The chief advantage that the ternary operator has over an if/else statement is that the entire structure is an expression. What that means is that we can treat the ternary expression as a value: we can assign it to a variable, pass it as an argument, and so on. Since if/else is a statement, we can't capture its result to a variable.

more ternary examples
var age = 20;
var beverage = (age >= 21) ? "Beer" : "Juice";
console.log(beverage); // "Beer"

Handling null values

One common usage is to handle a value that may be null:

let greeting = person => {
    let name = person ? person.name : `stranger`
    return `Howdy, ${name}`
}

console.log(greeting({name: `Alice`}));  // "Howdy, Alice"
console.log(greeting(null));             // "Howdy, stranger"

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator
Conditional chains

The ternary operator is right-associative, which means it can be "chained" in the following way, similar to an if … else if … else if … else chain


https://launchschool.com/books/javascript/read/flow_control#switchstatement
switch statement

The last conditional flow structure we want to discuss is the switch statement. A switch statement is similar to an if statement, but it has a different interface. It compares a single value against multiple values for strict equality (as with the === operator), whereas if can test multiple expressions with any condition.

1 What values do the following expressions evaluate to?

false || (true && false); // false
true || (1 + 2); // true first operand is true, so it returns true
(1 + 2) || true; // 3  first operand is 3 and is then returned. However, the || operator actually returns the value of one of the specified operands, so if this operator is used with non-Boolean values, it will return a non-Boolean value.   The or operator returns true when either operand is true and false when both operands are false.
true && (1 + 2); // 3  However, the && operator actually returns the value of one of the specified operands, so if this operator is used with non-Boolean values, it will return a non-Boolean value.     The and operator returns true when both operands are true and false when either operand is false.
false && (1 + 2); // false The first operation is FALSE. The and operator returns true when both operands are true and false when either operand is false.
(1 + 2) && true; // true use and logical operator, but starts with parentheses calculates number, both operands is true, 
(32 * 4) >= 129; // false compares two numbers, but starts with parentheses then compares
false !== !true; // false strict not operator and not operation turns boolean values to the opposite values
true === 4; // false boolean strictly compared with number 
false === (847 === '847'); // true strict operator
false === (847 == '847'); // false coercion
(!true || (!(100 / 5) === 20) || ((328 / 4) === 82)) || false;

2 Write a function, evenOrOdd, that determines whether its argument is an even number. If it is, the function should log 'even' to the console; otherwise, it should log 'odd'. For now, assume that the argument is always an integer.

3 Let's improve our previous implementation of evenOrOdd. Add a validation check to ensure that the argument is an integer. If it isn't, the function should issue an error message and return.

4 What does the following code log to the console, and why?

function barCodeScanner(serial) {
  switch (serial) {
    case '123':
      console.log('Product1');
    case '113':
      console.log('Product2');
    case '142':
      console.log('Product3');
    default:
      console.log('Product not found!');
  }
}

barCodeScanner('113');

Product2
Product3
Product not found!


It prints all the cases and the default case and stops. No break keyword is included. This creates a fall-through. It does not care that input 113 match Product2. Nothing tells the program to stop.


5 Refactor this statement to use an if statement instead.

return foo() ? 'bar' : qux();

if (foo()) {
  return 'bar';
} else {
  return qux();
}


6 What does this code output to the console?

function isArrayEmpty(arr) {
  if (arr) {
    console.log('Not Empty');
  } else {
    console.log('Empty');
  }
}

isArrayEmpty([]);

The array is not empty. the length of the array is calculated and returns 0. This is a value in the empty array.

7 Write a function that takes a string as an argument and returns an all-caps version of the string when the string is longer than 10 characters. Otherwise, it should return the original string. Example: change 'hello world' to 'HELLO WORLD', but don't change 'goodbye'.

function capital(stringInput) {
	if (stringInput.length > 10 && stringInput === 'string') {
		return stringInput.toUpperCase();
	} else {
		stringInput = stringInput;
	}
  return stringInput;
}

function getString(prompt) {
  let readlineSync = require('readline-sync');
  return (readlineSync.question(prompt.toString()));
}

let stringInput = getString('Enter any value: ');
console.log(`Is the string ${stringInput} capitalised ${stringInput.length > 10 ? '--YES--' : '--NO--'} ${capital(stringInput)} - Characters counted: ${stringInput.length}`);


8 Write a function that logs whether a number is between 0 and 50 (inclusive), between 51 and 100 (inclusive), greater than 100, or less than 0.


https://launchschool.com/books/javascript/read/loops_iterating
Loops and iterating

The increment operator (++) increments its operand by 1; that is, it adds 1 to the existing value. There's a corresponding decrement operator (--) that decrements a variable's value by 1. That is, it subtracts 1 from the value. JavaScript provides these operators since incrementing and decrementing by 1 are such commonplace operations.

There are two forms of ++: one that comes before the variable name (the pre-increment operator), and one that comes after (the post-increment operator). Both increment the variable, but they differ in what gets returned by the expression. The pre-increment form returns the new value of the variable, while the post-increment form returns the previous value of the variable.



There's a growing sentiment among some developers that the increment and decrement operators are harmful. It's easy to mistype them in ways that can lead to strange bugs, especially if you're not mindful of the return values. They recommend using the += and -= operators instead; it's only a few characters more to type.

Most developers still use them in the increment clause of a for loop:

for (var index = 0; index < 5; ++index) {
  // body of loop
}

However, they shouldn't be used anywhere else.


Looping Over Arrays With while

do/while Loop

A do/while loop differs visibly from a while loop, but its behaviors is almost identical. The crucial difference is that do/while always executes the code in the block at least once. A while loop can't make that guarantee since the initial condition may be falsy; if it is, the loop body doesn't run. In a do/while loop, the conditional check occurs at the end of the loop instead of the beginning which allows it to run the code at least once, even if the condition is falsy when the loop begins.


https://launchschool.com/books/javascript/read/loops_iterating#forloops
for loops

let names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];
let upperNames = [];

for (let index = 0; index < names.length; index += 1) {
  let upperCaseName = names[index].toUpperCase();
  upperNames.push(upperCaseName);
}

console.log(upperNames); // => ['CHRIS', 'KEVIN', 'NAVEED', 'PETE', 'VICTOR']


/https://launchschool.com/books/javascript/read/loops_iterating#controllingloops
Controlling loops

JavaScript uses the keywords continue and break to provide more control over loops. continue lets you start a new iteration of the loop, while break lets you terminate a loop early.
continue

Let's continue working with the names program. Suppose we want all the uppercase names in our upperNames array except 'Naveed'. The continue statement can help us do that.

 In contrast to the break statement, continue does not terminate the execution of the loop entirely: instead,

    In a while loop, it jumps back to the condition.

    In a for loop, it jumps to the update expression.

The continue statement can include an optional label that allows the program to jump to the next iteration of a labelled loop statement instead of the current loop. In this case, the continue statement needs to be nested within this labelled statement. 

If we can write looping logic without continue, why bother using it at all? You don't have to use continue, of course, but it often leads to a more elegant solution to a problem. Without continue, your loops get cluttered with nested conditional logic.


https://launchschool.com/books/javascript/read/loops_iterating#arrayiteration
Array Iteration

One feature of JavaScript that sets it apart from most other languages is that it has first-class functions. That means that functions are values: you can assign them to variables, pass them around as arguments to other functions, and even use them as return values in other functions. In our example, we're passing the anonymous function as an argument to forEach. That explains why the code is valid.

let names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];

names.forEach(function(name) {
  console.log(name);
});

One feature of JavaScript that sets it apart from most other languages is that it has first-class functions. That means that functions are values: you can assign them to variables, pass them around as arguments to other functions, and even use them as return values in other functions. In our example, we're passing the anonymous function as an argument to forEach. That explains why the code is valid.

When you pass a function as an argument to another function, that other function can call the function represented by the argument. That's what forEach does, and it's why this code is useful. As its name suggests, forEach loops through each element in an array, in sequence, starting with the first element. For each name, forEach invokes the anonymous function with the name as an argument. The anonymous function can do whatever it needs to do with the argument. In this case, it merely logs the name.

let names = ['Chris', 'Kevin', 'Naveed', 'Pete', 'Victor'];

names.forEach(name => console.log(name));

https://launchschool.com/books/javascript/read/loops_iterating#recursion

Recursion

Recursive functions are functions that call themselves. Such code doesn't look much like a loop, but there's a close relationship between loops and recursion. The relationship is close enough that we say that recursion is another way to create loops in JavaScript.

Let's create a function that uses recursion to calculate the nth number in the Fibonacci sequence. Each number in this sequence is the sum of the previous two numbers in the sequence:

Key definition of the Fibonacci sequence

fibonacci(0) = 0 // by definition
fibonacci(1) = 1 // by definition
fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2) // for all n >= 2

https://www.freecodecamp.org/news/how-to-factorialize-a-number-in-javascript-9263c89a4b38/
1 Modify the age.js program you wrote in the exercises for the Input/Output chapter. The updated code should use a for loop to display the future ages.

2 Write a function that computes and returns the factorial of a number by using a for loop. The factorial of a positive integer n, signified by n!, is defined as the product of all integers between 1 and n, inclusive:

What is factorialize?

When you factorialize a number, you are multiplying that number by each consecutive number minus one

the patern to calculate would be

0! = 1
1! = 1
2! = 2 * 1
3! = 3 * 2 * 1
4! = 4 * 3 * 2 * 1
5! = 5 * 4 * 3 * 2 * 1

3 The following code causes an infinite loop (a loop that never stops iterating). Why?

let counter = 0;

while (counter = 1) {
  console.log(counter);
  counter += 1;

  if (counter > 2) {
    break;
  }
}

// A conditional expression is required, counter == 1, but an assignment was made counter = 1 to assign 1 to replace 0. There is no condition to stop it, the break; wil not run, it will add 1 to each consecutive loop then re-assigns it to 1, until the program or browser crashes. An assignment is valid in Javascript in the conditional(which in a loop should have a built in error detector), so it will not give an error because the value is truthy, 1.

// https://betterprogramming.pub/stop-using-for-loops-to-iterate-over-arrays-5c46940e79d1
4 Does the following code produce an error? Why or why not? What output does this code send to the console?

for (let i = 0; i < 5;) {
  console.log(i += 1);
}


No error are created as the incrementExpression is optional. We increment the loop in the body of the code block 

5 The following code uses a randomNumberBetween function to generate a number between its first and second arguments. It uses a while loop to try to generate a number greater than 2. Refactor the code so that you don't need to call randomNumberBetween from two different locations, lines 6 and 10. Do not change the arguments you pass to randomNumberBetween.


function randomNumberBetween(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

let tries = 0;
let result = randomNumberBetween(1, 6);
tries += 1;

while (result <= 2) {
  result = randomNumberBetween(1, 6);
  tries += 1;
}

console.log('It took ' + String(tries) + ' tries to get a number greater than 2');

function fibonacci(number) {
  if (number < 2) return number; // 0 if number is 0, 1 if number is 1
  return fibonacci(number - 1) + fibonacci(number - 2);
}

include a do...while loop


6 Reimplement the factorial function from exercise 2 using recursion. Once again, you may assume that the argument is always a positive integer.


https://launchschool.com/books/javascript/read/arrays#whatisanarray
Arrays


Note that we must use the array's name twice, and, since we must account for the element at index 0, we must subtract 1 from the length to get the last element's index. Zero-based indexing seems strange at first, and it makes the arithmetic a little tricky, but, once you get used to it—it takes practice—it soon becomes second nature.

https://launchschool.com/books/javascript/read/arrays#modifyingarrays
Modify array


array[array.length] = 10

tis will add an array item to the current one

If you want the elements of the array to also be const, you can use the Object.freeze method:
> const MyArray1 = Object.freeze([1, 2, 3])
> MyArray1[1] = 5
> MyArray1
= [1, 2, 3]


It's important to realize that Object.freeze only works one level deep in the array. If your array contains nested arrays or other objects, the values inside them can still be changed unless they are also frozen
> const MyArray = Object.freeze([1, 2, 3, [4, 5, 6]])
> MyArray[3][1] = 0
> MyArray
= [1, 2, 3, [4, 0, 6]]

If you want the sub-array to be constant as well, you have to freeze it:
> const MyArray = Object.freeze([1, 2, 3, Object.freeze([4, 5, 6])])
> MyArray[3][1] = 0
> MyArray
= [1, 2, 3, [4, 5, 6]]

// nest your freeze


> array.push('a')
= 5               // the new length of the array

> array
= [ 1, 4, 3, 10, 'a' ]

> array.push(null, 'xyz')
= 7

> array
= [ 1, 4, 3, 10, 'a', null, 'xyz' ]

NB: The push method appends its arguments to the caller (the array), which mutates the caller. It then returns the array's new length. Don't forget that methods and functions perform actions and return values. You must be careful to distinguish between these two things. push appends elements to the end of the caller array, but it returns the array's updated length. Note that it does not return the modified array! New JavaScript programmers often get confused over this difference and spend hours puzzling over why a function isn't returning the value they expect. Check the documentation if you have any doubt.

Adding Elements With concat

The concat method is similar to push, but it doesn't mutate the caller. It concatenates two arrays and returns a brand new array that contains all the elements from the original array followed by all of the arguments passed to it:

array.concat(42, 'abc')
= [ 1, 4, 3, 10, 'a', null, 'xyz', 42, 'abc' ]


Pop mutates the array, it deletes elements

> array.pop()
= 'xyz'            // removed element value

> array
= [ 1, 4, 3, 10, 'a', null ]

Splice mutates an arrsy
The splice method lets you remove one or more elements from an array, even those that aren't at the end of the array:

> array.splice(3, 2)
[ 10, 'a' ]

> array
= [ 1, 4, 3, null ]



Iterating With forEach

To use forEach, you need a callback function that you pass to forEach as an argument. A callback function is a function that you pass to another function as an argument. The called function invokes the callback function when it runs. The forEach method invokes its callback once for each element, passing it the element's value as an argument. forEach always returns undefined.

let array = [1, 2, 3];
array.forEach(function(num) {
  console.log(num); // on first iteration  => 1
                    // on second iteration => 2
                    // on third iteration  => 3
}); // returns `undefined`

Transforming Arrays With map

forEach works well when you want to use the values of an array's elements. Suppose, though, that you want to create a new array whose values depend on the original contents of the array. For instance, suppose you want to create a new array that contains the squares of all the numbers in the calling array. With forEach, you might end up with something like this:

let numbers = [1, 2, 3, 4]
let squares = [];
numbers.forEach(num => squares.push(num * num));
squares
= [ 1, 4, 9, 16 ]

> numbers
= [ 1, 2, 3, 4 ]

let numbers1 = [1, 2, 3, 4]
let squares1 = numbers.map(num => num * num);
squares1
= [ 1, 4, 9, 16 ]

> squares1 = numbers1.map(num => num * num);
= [ 1, 4, 9, 16 ]

The first 4 lines of this code have the same result as the previous example using forEach. However, map returns a new array that contains one element for each element in numbers, with each element set to the return value of the callback: the squares of the numbers in this case. This code is more compact than the forEach code, and, better yet, it has no side effects; the callback doesn't update squares (the return value of map does that), and we don't have to reset the variable if we rerun the same code.

Filtering Arrays with filter

The filter method is another array iteration method. It returns a new array that includes all elements from the calling array for which the callback returns a truthy value. That's a mouthful. Some code should help clarify what filter does:

let numbers2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2]
numbers2.filter(num => num > 9)
= [ 5, 6, 7, 8, 9, 10 ]

> numbers2
= [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2 ]


Building New Values from Arrays with reduce

The reduce method effectively reduces the contents of an array to a single value. It is, perhaps, one of the hardest array iteration methods to understand, but it is also one of the most fundamental. You can build forEach, map, and filter with reduce, as well as a number of other iterative methods defined for Arrays.

reduce takes two arguments: a callback function and a value that initializes something called the accumulator. In its simplest form, the callback function takes two arguments: the current value of the accumulator and an element from the array. It returns a value that will be used as the accumulator in the next invocation of the callback. That sounds more complicated than it is, so let's take a look at two simple uses of reduce:


> let arr = [2, 3, 5, 7]
> arr.reduce((accumulator, element) => accumulator + element, 0)
= 17

> arr.reduce((accumulator, element) => accumulator * element, 1)
= 210

 let strings = ['a', 'b', 'c', 'd']
strings.reduce((accumulator, element) => { return accumulator + element.toUpperCase() }, '');
strings.reduce((accumulator, element) => { return accumulator + element.padEnd(2, '.') }, '');

https://launchschool.com/books/javascript/read/arrays#arrayscanbeodd
Arrays can be odd

let arr = [1, 2, 3]
typeof arr
= 'object'

detect the array
let arr = [1, 2, 3]
Array.isArray(arr)

If you change an array's length property to a new, smaller value, the array gets truncated; JavaScript removes all elements beyond the new final element.


https://launchschool.com/books/javascript/read/arrays#nestedarrays
Nested arrays

Array elements can contain anything, including other arrays. You can create arrays with arrays inside them and even arrays inside those inner arrays. Suppose you want to track all of the teams playing in a mixed doubles tennis tournament. You might create an array like this.

Array Equality


JavaScript treats two arrays as equal only when they are the same array: they must occupy the same spot in memory. This rule holds for JavaScript objects in general; objects must be the same object. For this reason, the second example returns true while the first one returns false. Assigning a to b makes b refer to the same array as a; it doesn't create a new array.


https://launchschool.com/books/javascript/read/arrays#otherarraymethods
Other array methods

The includes method determines whether an array includes a given element:

Internally, includes uses === to compare elements of the array with the argument. That means we can't use includes to check for the existence of a nested array or an object unless we have the same object or array we're looking for:

> let inner = [3, 4];
> let a = [1, 2, inner, 5]

> a.includes([3, 4])
= false

> a.includes(inner)
= true

The sort method is a handy way to rearrange the elements of an array in sequence. It returns a sorted array.

> let a = ["e", "c", "h", "b", "d", "a"]
> a.sort()
= [ 'a', 'b', 'c', 'd', 'e', 'h' ]


slice

The slice method—not the splice method you met earlier—extracts and returns a portion of the array. It takes two optional arguments. The first is the index at which extraction begins, while the second is where extraction ends:


reverse

The reverse method reverses the order of an array.

> let numbers = [1, 2, 3, 4]
> numbers.reverse()
= [ 4, 3, 2, 1 ]

> numbers
= [ 4, 3, 2, 1 ]


1 In the following code, what are the final length values for array1, array2, array3, array4, and array5?

let array1 = [1, 2, undefined, 4];
array1.length
= 4
Object.keys(array1)
= [ '0', '1', '2', '3' ]
array1
= [ 1, 2, undefined, 4 ]
All elements are counted. Undefined as well as an index value.

let array2 = [1];
array2.length = 5;
= 1
Object.keys(array2)
= [ '0' ]
array2
= [ 1, <4 empty items> ]
The element in the array is expanded past the original size. This created 1 assigned original item, and 4 empty unassigned items.

let array3 = [];
array3[-1] = [1];
array3.length
= [ 0 ]
Object.keys(array3)
= [ '-1' ]
array3
= [ '-1': [ 1 ] ]
The element added to the array is a negative value and is counted as a key by Object.keys. But array.length returns 0 elements, all negative values are not counted and non-integer numbers


let array4 = [1, 2, 3, 4, 5];
array4.length = 3;
array4.length
= [3]
Object.keys(array4)
= [ '0', '1', '2' ]
array4
= [ 1, 2, 3 ]
truncated to shortest length, being 3


let array5 = [];
array5[100] = 3;
array5.length
= [101]
Object.keys(array5)
= [ '100' ]
array5
= [ <100 empty items>, 3 ]
The highest index value plus 1 is counted: 100 plus 1 = 101


2 Log all of the even values from myArray to the console.

let myArray = [1, 3, 6, 11, 4, 2, 4, 9, 17, 16, 0];


for (let i = 0; i < myArray.length; i += 1) {
  let value = myArray[i];
  if (value % 2 === 0) {
    console.log(value);
  }
}

3 Let's make the problem a little harder. In this problem, we're again interested in even numbers, but this time the numbers are in nested arrays in a single outer arr

let myArray = [ [1, 3, 6, 11], [4, 2, 4], [9, 17, 16, 0] ];

for (let i = 0; i < myArray.length; i += 1) {
  for (let j = 0; j < myArray[i].length; j += 1) {
    let value = myArray[i][j];
    if (value % 2 === 0) {
      console.log(value);
    }
  }
}

Our approach is again straightforward, but it's a bit verbose. However, the chained brackets in myArray[i][j] make it visually explicit that we're dealing with a two-dimensional nested array.

4 Let's try another variation on the even-numbers theme.

We'll return to the simpler one-dimensional array. In this problem, we want to use the map function to create a new array that contains one element for each element in the original array. If the element is an even value, then the corresponding element in the new array should contain the string 'even'; otherwise, the element in the new array should contain 'odd'.

5 Write a findIntegers function that takes an array argument and returns an array that contains only the integers from the input array. Use the filter method in your function.

6 Use map and filter to first determine the lengths of all the elements in an array of string values, then discard the even values (keep the odd values).

let things = [1, 'a', '1', 3, NaN, 3.1415, -4, null, false];
let integers = findIntegers(things);
console.log(integers); // => [1, 3, -4]


7 Use reduce to compute the sum of the squares of all of the numbers in an array:

let array = [3, 5, 7];
console.log(sumOfSquares(array)); // => 83


8 This problem is more challenging than most in this book. Don't worry if you can't solve it on your own.

Write a function similar to the oddLengths function from Exercise 6, but don't use map or filter. Instead, try to use the reduce method.


9 Without using a for, while, or do/while loop, write some code that checks whether the number 3 appears inside these arrays:

> let numbers1 = [1, 3, 5, 7, 9, 11];
> let numbers2 = [];
> let numbers3 = [2, 4, 6, 8];


10 Write some code to replace the value 6 in the following array with 606:

let arr = [
  ["hello", "world"],
  ["example", "mem", null, 6, 88],
  [4, 8, 12]
];


https://launchschool.com/books/javascript/read/objects#whatareobjects
Objects


> let person = { name: 'Jane', age: 37, hobbies: ['photography', 'genealogy'] }


Objects vs. Primitives

You may remember that JavaScript has two categories of data types: primitives and objects. The primitive types are strings, numbers, booleans, null, and undefined, bigints, and symbols. Primitive types are the simplest, most basic types in JavaScript.

Objects include, but aren't limited to, the following types:

    Simple Objects
    Arrays
    Dates
    Functions

We learned about simple objects in the previous section; they're structures that contain multiple named values. Arrays are also objects, but they use integer indexes instead of keys. We learn about Date and Function objects in the Core Curriculum.


https://launchschool.com/books/javascript/read/objects#prototypes
Prototypes

An interesting and handy feature of JavaScript objects is that they can inherit from other objects. When an object a inherits from object b, we say that b is the prototype of a. The practical implication is that a now has access to properties defined on b even though it doesn't define those properties itself.


Object prototypes and inheritance have a great deal of relevance in Object Oriented Programming (OOP). We discuss these concepts here since it is relevant to our discussion of iterating over object properties in the next section. All you need to know right now is that inheritance lets one object use the properties defined by another object and that prototypes implement inheritance in JavaScript.


https://launchschool.com/books/javascript/read/objects#iteration
Iteration

The for/in loop

The for/in loop behaves similarly to an ordinary for loop. The syntax and semantics are easier to understand since you don't need an initializer, ending condition, or increment clause. Instead, the loop iterates over all the keys in the object. In each iteration, it assigns the key to a variable which you then use to access the object's values. As always, seeing a concept in action is helpful:

One feature—or downside, depending on how you look at it—of for/in is that it iterates over the properties of an object's prototypes as well:

let obj1 = { a: 1, b: 2 }
let obj2 = Object.create(obj1);
obj2.c = 3;
obj2.d = 4;

for (let prop in obj2) {
  console.log(obj2[prop]);
}         // => 3
          //    4
          //    1
          //    2


This behavior is undesirable when you want to limit iteration to an object's own properties, i.e., properties it defined for itself, not properties it inherited. We can use the hasOwnProperty method to get around that problem. It takes the name of a property and returns true if it is the name of one of the calling object's own properties, false if it is not.

let obj1 = { a: 1, b: 2 }
let obj2 = Object.create(obj1);
obj2.c = 3;
obj2.d = 4;

for (let prop in obj2) {
  if (obj2.hasOwnProperty(prop)) {
    console.log(obj2[prop]);
  }
} // => 3
  //    4


Object.keys

The Object.keys static method returns an object's keys as an array. You can iterate over that array using any technique that works for arrays. For instance:

let person = {
  name: 'Bob',
  age: 30,
  height: '6 ft'
};

let personKeys = Object.keys(person);
console.log(personKeys);          // => ['name', 'age', 'height']
personKeys.forEach(key => {
  console.log(person[key])
});                               // => Bob
                                  //    30
                                  //    6 ft

Order of Object Properties

Older versions of the ECMAScript standard (prior to ES6) don't guarantee the iteration order for an object's property keys. Many JavaScript engines took advantage of this non-guarantee. In older versions of JavaScript, you can't rely on any particular iteration order. Even in the same engine, you might get different results in separate runs of a program.

Modern versions of the standard (ES6+) do guarantee the iteration order for an object's property keys. However, this order is somewhat complex. The order is based on:

    the types of the property keys (strings come before symbols)
    the values of the keys (non-negative integers come first), and
    the order in which the keys were added to the object.

It's tempting to rely on this predictable order, but the order isn't straightforward except in the simplest cases.

https://launchschool.com/books/javascript/read/objects#commonoperations
Common Operations

// https://medium.com/@fknussel/arrays-objects-and-mutations-6b23348b54aa
Unlike JavaScript arrays (which, you may remember, are objects), most JavaScript objects don't have an abundance of methods that you can apply in your day to day usage. Most operations on objects involve iterating over the properties or their values. More often than not, you'll reach for methods that extract the keys or values of an object and then iterate over the resulting array. We saw an example of that when we used Object.keys to extract an object's keys as an array and then iterated over the array.

Object.entries

While Object.keys and Object.values return the keys and values of an object, respectively, the Object.entries static method returns an array of nested arrays. Each nested array has two elements: one of the object's keys and its corresponding value:

let person = { name: 'Bob', age: 30, height: '6ft' };
console.log(Object.entries(person)); // => [[ 'name', 'Bob' ], [ 'age', 30 ], [ 'height', '6ft' ]]

Object.assign

You may sometimes want to merge two or more objects, i.e., combine the key-value pairs into a single object. The Object.assign static method provides this functionality:

> let objA = { a: 'foo' }
= undefined

> let objB = { b: 'bar' }
= undefined

> Object.assign(objA, objB)
= { a: 'foo', b: 'bar' }




Note that objB isn't mutated. If you need to create a new object, use an empty object as Object.assign's first argument. Note that Object.assign can take more than two arguments:



> objA = { a: 'foo' }
= undefined

> objB = { b: 'bar' }
= undefined

> Object.assign({}, objA, objB)
= { a: 'foo', b: 'bar' }

> objA
= { a: 'foo' }

> objB
= { b: 'bar' }


Objects vs. Arrays

This chapter and the last discussed two fundamental data structures: objects and arrays. It can seem overwhelming when you look at all of the different ways to represent data with code. Don't feel daunted, however. You'll use objects and arrays often. The more you use them, the more you'll learn about them. It's impossible to learn everything in the beginning, so put some effort into learning the basics, then build from there.

When you need to choose between an object or an array to store some data, ask yourself a few questions:

    Do the individual values have names or labels? If yes, use an object. If the data doesn't have a natural label, an array should suffice.

    Does order matter? If yes, use an array.

    Do I need a stack or queue structure? Arrays are good at mimicking simple "last-in-first-out" stacks and "first-in-first-out" queues.

As you grow as a developer, your familiarity with these data structures may affect which one you choose to solve a problem. Practice and experiment with each to find out which data structure works best in which situations.



 Exercises

1 Given the following code, how can you access the name of the person?


let person = {
  name:       'Bob',
  occupation: 'web developer',
  hobbies:    'painting',
};


2 Which of the following values are valid keys for an object?

    1 // yes
    '1' // yes
    undefined // yes
    'hello world' // yes
    true // yes
    'true' // true

    All the listed values are valid keys. Note, though, that JavaScript coerces the non-string key values to strings. Given the listed values, 1 and '1' represent the same key, as do true and 'true'. This equivalency will bite you at some point; it's inevitable, so be ready.


What Things Aren't Objects or Primitives?

Objects and primitive values are the data and functions that you use in your program. Anything that isn't data or a function is neither a primitive value nor an object. That includes:

    variables and other identifiers such as function names
    statements such as if, return, try, while, and break
    keywords such as new, function, let, const, and class
    comments
    anything else that is neither data nor a function

You may remember that JavaScript has two categories of data types: primitives and objects. The primitive types are strings, numbers, booleans, null, and undefined, bigints, and symbols. Primitive types are the simplest, most basic types in JavaScript.

Objects include, but aren't limited to, the following types:

    Simple Objects
    Arrays
    Dates
    Functions


3 Use object literal syntax (e.g., { key: value, ... } notation) to create an object that behaves as an array in a for statement. The object should contain at least 3 elements. You should place your code between the braces in the let statement:

let myArray = {
};

for (let i = 0; i < myArray.length; i += 1) {
  console.log(myArray[i]);
}

4 Create an array from the keys of the object obj below, with all of the keys converted to uppercase. Your implementation must not mutate obj.

let obj = {
  b: 2,
  a: 1,
  c: 3,
};

5 Create a new object named myObj that uses myProtoObj as its prototype.

6 Which of the following values are primitive values? Which are objects? Which are neither?



    "foo" // primitive
    3.1415 // primitive
    [ 'a', 'b', 'c' ] // object
    false // primitive
    foo // neither
    function bar() { return "bar"; } // object
    undefined // primitive
    { a: 1, b: 2 } // object

7 Add a qux property with value 3 to the myObj object we created in the previous exercise. Now, examine the following code snippets:


https://launchschool.com/books/javascript/read/more_stuff
More stuff


What's crucial to understand at this point is that variables that have primitive values store those values at the memory location associated with the variable. In our example, a and b point to different memory locations. When we assign a value to either variable, the value gets stored in the appropriate memory location. If you later change one of those memory locations, it does not affect the other memory location, even if they started off with the same value. Therefore, the variables are independent when they contain primitive values.

In reality, string values aren't stored in variables in the same way as most primitive values, but they act like they are. Don't worry about how they are stored -- just remember how they act.

Working with Objects and Non-Mutating Operations

let obj = { a: 1 };
obj = { b: 2 };
obj.c = 3;

What does that look like in the computer? As we learned earlier, creating new variables causes JavaScript to allocate a spot somewhere in its memory for the value. However, with objects, JavaScript doesn't store the value of the object in the same place. Instead, it allocates additional memory for the object, and places a pointer to the object in the space allocated for the variable. Thus, we need to follow two pointers to get the value of our object from its variable name. The process looks like this:

Nn this example, obj is always at address 0x1248. The value at that address is a pointer to the actual object. While the pointer to the object can change, obj itself always has the same address. In the above table, we can see that obj's address doesn't change, but its value changes to the address of the object currently assigned to the variable.


Let's look at another example. This time, we'll use arrays. Remember that arrays in JavaScript are objects, and almost everything we say about arrays holds for objects as well.

> let c = [1, 2]
> let d = c
> c = [3, 4]
> c
= [ 3, 4 ]

> d
= [ 1, 2 ]

Again, this example holds no surprises. For the moment, though, let's ignore what happens on line 2. We can assume that variables c and d end up with the same value after line 2 runs. Reassigning c on line 3 creates a new array, but the code doesn't affect the value of d. The two variables reference different arrays.

This code works as expected since reassignment changes the pointer value of c to reference the new [3, 4] object. Though d originally had the same pointer value as c, it was stored in a different memory location (the location of d). Thus, when we reassign c, we're not changing d -- it still points to the original array.

As with primitive values, this is straightforward: each variable has a value, and reassigning values does not affect any other variables that happen to have the same value. Thus, c and d are independent variables.


> let e = [1, 2]
> let f = e
> e.push(3, 4)
> e
= [ 1, 2, 3, 4 ]

> f
= [ 1, 2, 3, 4 ]


Now, that's interesting and puzzling. We mutated the array referenced by e, but it also changed the array referenced by f! How can that happen? Therein lies the source of a lot of confusion for new programmers.

As we saw a little earlier, objects (and arrays) aren't stored in the memory location used by the variable. Instead, that memory location points to yet another memory location. That's where the object is ultimately stored.

The use of pointers has a curious effect when you assign a variable that references an object to another variable. Instead of copying the object, JavaScript only copies the pointer. Thus, when we initialize f with e, we're making both e and f point to the same array: [1, 2]. It's not just the same value, but the same array in the same location in memory. The two variables are independent, but since they point to the same array, that array is dependent on what you do to both e and f.

Okay, that's good. What happens if we mutate a primitive value? Oops! You can't do that: all primitive values are immutable. Two variables can have the same primitive value. However, since primitive values are stored in the memory address allocated for the variable, they can never be aliases. If you give one variable a new primitive value, it doesn't affect the other.


Gotcha

If you've followed along so far, you may think that reassignment never mutates anything. As the following code demonstrates, however, that isn't always true:

> let g = ['a', 'b', 'c']
> let h = g
> g[1] = 'x'
> g
= [ 'a', 'x', 'c' ]

> h
= [ 'a', 'x', 'c' ]


for/in and for/of

Two useful variants for the for loop are the for/in and for/of loops. These loops use a variant syntax to loop easily over object properties.

The for/in statement iterates over all enumerable properties of an object including any properties inherited from another object. For now, you don't need to know anything about inheritance or enumerable properties -- for/in will usually do what you want.


let obj = { foo: 1, bar: 2, qux: 'c' };
for (let key in obj) {
  console.log(key);
}

let obj = { foo: 1, bar: 2, qux: 'c' };
for (let index in obj) {
  console.log(obj[index]);
}

for/of is similar to for/in, but it iterates over the values of any "iterable" collection. For our purposes, the only iterable collections are arrays and strings. Let's see what happens when we pass a string to for/of:

let arr = [ 10, 20, 30 ]
for (let value of arr) {
  console.log(value);
}



https://launchschool.com/books/javascript/read/more_stuff#methodchaining
Method chaining


let str = 'Pete Hanson';
let names = str.toUpperCase().split(' ').reverse().join(', ');
console.log(names); // => HANSON, PETE


On line 2, we have a long chain of method calls. First, we call toUpperCase() on the string str, which returns 'PETE HANSON'. Then we call split(' ') on the returned string, which in turn returns the array ['PETE', 'HANSON']. We then use the array to invoke reverse(), which returns a new array, ['HANSON', 'PETE']. In the last step, we join the elements of the array together with a comma and space between elements, which returns the string 'HANSON, PETE'.



https://launchschool.com/books/javascript/read/more_stuff#regex
Regex

A regular expression—a regex—is a sequence of characters that you can use to test whether a string matches a given pattern. They have a multitude of uses:

    Check whether the string "Mississippi" contains the substring ss.
    Print the 3rd word of each sentence from a list of sentences.
    Replace all instances of Mrs in some text with Ms.
    Does a string begin with the substring St?
    Does a string end with the substring art?
    Does a string contain any non-alphanumeric characters?
    Does a string contain any whitespace characters?
    Replace all non-alphanumeric characters in a string with a hyphen (-).

That's a tiny sample of the kinds of operations you can perform with regex.

function has_a_or_e(string) {
  let results = string.match(/[ae]/g);
  if (results) {
    // a non-null return value from match is truthy
    console.log(`We have a match! ${results}`);
  } else {
    // a null return value from match is falsy
    console.log('No match here.');
  }
}

has_a_or_e("basketball"); // => We have a match! a,e,a
has_a_or_e("football");   // => We have a match! a
has_a_or_e("hockey");     // => We have a match! e
has_a_or_e("golf");       // => No match here.

Since match must generate information above and beyond a simple boolean value, it can have performance and memory costs. test is more efficient, so try to use it when you don't need to know anything other than whether the regex matched the string.


https://launchschool.com/books/javascript/read/more_stuff#themathobject
Most programs need to perform some arithmetic or mathematical operations. That doesn't mean you need much math as a programmer; most programs need little more than some basic arithmetic like a + 1.

However, sometimes you need a bit more: you may need to calculate the square root of a number, determine the smallest number in a collection, or even do some trigonometric calculations. You can use well-known algorithms to make these computations, but you don't have to. The JavaScript Math object provides a collection of methods and values that you can use without a complete understanding of how they work.



https://launchschool.com/books/javascript/read/more_stuff#dates
Dates

Suppose you want to determine the day of the week that December 25 occurred on in 2012. How would you go about that? You may be able to come up with an appropriate algorithm on your own, but working with dates and times is a messy process. It's often much harder than you think.

You don't have to work that hard, however. JavaScript's Date constructor creates objects that represent a time and date. The objects provide methods that let you work with those values. In particular, it's not hard to determine the day of the week that corresponds to a date:


Getting a day name takes a bit more work, but it's not difficult:
function getDayOfWeek(date) {
  let daysOfWeek = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday',
  ];

  return daysOfWeek[date.getDay()];
}

let date = new Date('December 25, 2012');
console.log(getDayOfWeek(date)); // => Tuesday


https://launchschool.com/books/javascript/read/more_stuff#exceptions
exceptions


Applications that interact with the real world encounter a significant degree of unpredictability. If a user enters incorrect information or a file gets corrupted, your program must know how to respond. If it doesn't, it may crash or, worse yet, produce incorrect results.

JavaScript is a forgiving language. It doesn't issue error messages in scenarios that most other languages do. Instead, it "fails silently" by returning a value like NaN, undefined, null, or even -1.

Silent failures are both useful and dangerous. A programmer can take advantage of silent errors to simplify some code; often, you don't have to deal with the silent error right away, but can postpone handling it or even ignore it entirely. Ultimately, though, you need to deal with errors somehow, even silent errors.

Not all errors in JavaScript are silent. There are some situations where JavaScript is less forgiving; that's where exceptions come into play. In such cases, JavaScript raises an error, or throws an exception, then halts the program if the program does not catch the exception.

Exception handling is a process that deals with errors in a manageable and predictable manner. For now, you should be familiar with how exception handling works and what it looks like in a program. The reserved words try and catch (and sometimes finally) often occur in real-world JavaScript programs, so you should learn enough to understand what they do.

let names = ['bob', 'joe', 'steve', undefined, 'frank'];

names.forEach(name => {
  try {
    console.log(`${name}'s name has ${name.length} letters in it.`);
  } catch (exception) {
    console.log('Something went wrong');
  }
});


SyntaxError

A special kind of exception occurs if the code can't be handled as valid JavaScript. Such errors cause JavaScript to raise a SyntaxError. A SyntaxError is special in that it occurs immediately after loading a JavaScript program, but before it begins to run. Unlike a TypeError exception that is dependent upon runtime conditions, JavaScript detects syntax errors based solely on the text of your program. Since they are detected before execution begins, you can't use a try/catch statement to catch one.




https://launchschool.com/books/javascript/read/more_stuff#readingstacktraces
Stack trace 


https://launchschool.com/books/javascript/read/more_stuff#essixandbeyond
ES6

Most professionals call the language we've been learning JavaScript, but the official name is ECMAScript. The JavaScript name exists for historical reasons.

The language has seen numerous revisions and experienced a host of changes since its initial version. ECMAScript 6, or ES6 as it's commonly known, is a recent version of the language specification that added a variety of modern features. You may also encounter the name ES2015.

The let and const keywords we've used in this book are part of ES6. Before ES6, JavaScript didn't have block scopes. All JavaScript variables were either locally scoped to a function or globally scoped to the program. These keywords solve an entire class of problems having to do with scope and how JavaScript translates code into something it can run.

Another ES6 feature that we learned about in this book is arrow functions. Among other benefits, they solve a problem called lost execution context, or, more plainly, context loss.


Exercises

1 What does this code log to the console? Why?

let array1 = [1, 2, 3];
let array2 = array1;
array1[1] = 4;
console.log(array2);

// array1 gets get assigned to memory, the array itself has values that are primitive values. These values are immutable. The variable and the array shares the same memory address. Following this, array2 gets assigned to array 1. Bot now point the the same memory address and share the same array with values 1,2,3. In the following line the code executes an array value mutation. At index 1 in the array 2 gets replaced with 4. This action permanently mutates the array. As both variable, array1 and array2 points to the same address in memory, the return will be the same mutated array[1,4,3]. This action indicates that references or pointers are assigned to each variable


2 What do the following error message and stack trace tell you?

$ node exercise2.js
/Users/wolfy/tmp/exercise2.js:4
  console.log(greeting);
              ^

ReferenceError: greeting is not defined
    at hello (/Users/wolfy/tmp/exercise2.js:4:15)
    at Object.<anonymous> (/Users/wolfy/tmp/exercise2.js:13:1)
    at Module._compile (internal/modules/cjs/loader.js:721:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:732:10)
    at Module.load (internal/modules/cjs/loader.js:620:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:560:12)
    at Function.Module._load (internal/modules/cjs/loader.js:552:3)
    at Function.Module.runMain (internal/modules/cjs/loader.js:774:12)
    at executeUserCode (internal/bootstrap/node.js:342:17)
    at startExecution (internal/bootstrap/node.js:276:5)

// the stack trace tells us that exercise2.js on line 4 has an error. The error called is a Reference error, that states that greeting is not defined. It further indicates the error starts at ine 4 on column 15. The next line indicates that then anonymous callback, encountered a error on line 13 at column 1, which originates higher in the stack to the above issue of not defined at the global program level.  the rest of the lines is additional code compiled by node.

3 Write some code to output the square root of 37.

Math.sqrt(37)
= 6.082762530298219

4 Given a list of numbers, write some code to find and display the largest numeric value in the list.
List 	           Max
|1, 6, 3, 2 	    | 6
|-1, -6, -3, -2 	|-1
|2, 2 	          |2

console.log(Math.max(1,6,3,2));
console.log(Math.max(-1,-6,-3,-2));
console.log(Math.max(2,2));

const array1 = [1, 6, 3, 2 ];
console.log(Math.max(...array1));
const array2 = [-1,-6,-3,-2];
console.log(Math.max(...array2));
const array3 = [2,2];
console.log(Math.max(...array3));
// However, both spread (...) and apply will either fail or return the wrong result if the array has too many elements, because they try to pass the array elements as function parameters. See Using apply and built-in functions for more details. The reduce solution does not have this problem. 

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#using_apply_and_built-in_functions
But beware: by using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (that is, more than tens of thousands of arguments) varies across engines. (The JavaScriptCore engine has hard-coded argument limit of 65536.


var arr = [1,6,3,2];
var max = arr.reduce(function(a, b) {
    return Math.max(a, b);
}, 0);

max; // 6


5 What does the following function do?

function doSomething(string) {
  return string.split(' ').reverse().map((value) => value.length);
}

// This code converts a string into an array of words, reverses that array, and then returns a new array that contains the lengths of the words. It assumes that a single space character delimits the words in the original string.

Thus:

console.log(doSomething("Pursuit of happiness")); // => [ 9, 2, 7 ]

6 Write a function that searches an array of strings for every element that matches the regular expression given by its argument. The function should return all matching elements in an array.

Example

let words = [
  'laboratory',
  'experiment',
  'flab',
  'Pans Labyrinth',
  'elaborate',
  'polar bear',
];

let allMatches = /(\w+|)(lab)(\w+|)/g;

console.log(allMatches(words, /lab/)); // => ['laboratory', 'flab', 'elaborate']

7 What is exception handling and what problem does it solve?

// It allows a user to catch errors in as section or block of code. The advantage mainly is to catch any errors and then continue to run the rest of the code block or section. Exception handling allows a coe to continue after an error occurred, which is'nt detrimental to the rest of the program.


8 Earlier, we learned that Number.isNaN(value) returns true if value is the NaN value, false otherwise. You can also use Object.is(value, NaN) to make the same determination.

Without using either of those methods, write a function named isNotANumber that returns true if the value passed to it as an argument is NaN, false if it is not.

function isNotANumber(value) {
  return value !== value;
}

9 Earlier, we learned that JavaScript has multiple versions of the numeric value zero. In particular, it has 0 and -0. These numbers, while being mathematically nonsensical, are distinct values in JavaScript. We won't get into why JavaScript has a 0 and -0, but it can be useful in some cases.

> 0 === -0
= true

> String(-0)
= '0'

> let value = -0;
> Object.is(value, 0)
= false

> Object.is(value, -0)
= true


function isNegativeZero(value) {
  return 1 / value === -Infinity;
}


10 Consider this code:

> let x = "5"
> x = x + 1
= "51"

Now, consider this code:

> let y = "5"
> y++

What gets returned by y++ in the second snippet, and why?

// 5 as a number, because the ++ decrement operator is used, the value is coerced to a number, but not added to to 6. The value returned is 5 the coerced value that takes precedence.


The return value is the numeric value 5.

If you apply ++ to a string, JavaScript coerces it into a number. In this case, "5" gets coerced to the number 5. After coercion, it then increments the value to 6. However, the return value is 5 since the post-increment operator (y++) returns the original value of y, not the incremented value.

This shows that x++ is not the same thing as x = x + 1.


*/